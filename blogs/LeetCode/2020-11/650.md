---
title: leetcode650 只有两个键的键盘
date: 2020-11-21
categories:
 - LeetCode
tags:
 - 动态规划
 - 字符串编辑
---

:::tip

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

1. Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
2. Paste (粘贴) : 你可以粘贴你上一次复制的字符。

给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

分素数，和不是素数。

:::

<!-- more -->



## 题目

[650. 只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：

1. Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
2. Paste (粘贴) : 你可以粘贴你上一次复制的字符。

给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。

**示例 1**:

输入: 3
输出: 3
解释:
最初, 我们只有一个字符 'A'。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 'AA'。
第 3 步, 我们使用 Paste 操作来获得 'AAA'。

**说明**:

n 的取值范围是 [1, 1000] 。

## 思路

**状态**：`dp[i]`表示打印出 i 个 ‘A’ 的最少操作次数。

当n是素数时，那么就是复制一次，然后不断粘贴。例如n = 5，操作`CPPPP`为5次，11，操作`CPPPPPPPPPP`为11次；

当n不是素数时，例如15，那么就将n分解：

15 = 5 * 3	 `CPPPP + CPP `（8次）

15 = 3 * 5 	`CPP + CPPPP`  （8次）

.......

归纳：n = a * b      `dp[a] + dp[b]  = dp[n]`

a和b的位置交换，n的操作次数依然一样。

**解释**：

刚开始的Copy的基数是1，得到前半部分的因子a，得到因子a的操作次数为`dp[a]`

后半部分的因子b的刚开始Copy的基数就是前半部分因子a了，次数`dp[b]`就是将因子a扩大b倍所需要的次数。

所以1->a->n，所以就有这两次操作，总操作次数：`dp[a] + dp[b]`

b也可以 表示为`n / a`

**状态转移方程**：

如果 i 是素数：`dp[i] = i`

如果 i 不是素数： `dp[i] = min(dp[i], dp[j] + dp[i / j])` (其中j是 i 的因子，范围2<= j <=sqrt(i))

**结果**：

`dp[n]`

## 代码



```java
class Solution {
    public int minSteps(int n) {
        int[] dp  = new int[n + 1];
        dp[1] = 0;
        for(int i = 2; i <= n; i++){
            dp[i] = i;
            for(int j = 2; j <= Math.sqrt(i); j++){
                if(i % j == 0){
                    dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
                }
            }
        }
        return dp[n];
    }
}
```



![image-20201121193300717](https://i.loli.net/2020/11/21/AdKJjSCtaevUNiE.png)